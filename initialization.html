<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/initialization.md at 2022-07-02
 | Rendered using Apache Maven Fluido Skin 1.9
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>socket.io-client &#x2013; Initialization</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.9.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.9.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <a href="https://github.com/socketio/socket.io-client-java">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"
        alt="Fork me on GitHub">
    </a>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h2>Socket.IO Java client</h2>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2022-07-02<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 2.0.2-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="installation.html" title="Installation"><span class="none"></span>Installation</a></li>
    <li class="active"><a href="#"><span class="none"></span>Initialization</a></li>
    <li><a href="emitting_events.html" title="Emitting events"><span class="none"></span>Emitting events</a></li>
    <li><a href="listening_to_events.html" title="Listening to events"><span class="none"></span>Listening to events</a></li>
    <li><a href="socket_instance.html" title="The Socket instance"><span class="none"></span>The Socket instance</a></li>
    <li><a href="migrating_from_1_x.html" title="Migrating from 1.x"><span class="none"></span>Migrating from 1.x</a></li>
    <li><a href="faq.html" title="FAQ"><span class="none"></span>FAQ</a></li>
   <li class="nav-header">Miscellaneous</li>
    <li><a href="changelog.html" title="Changelog"><span class="none"></span>Changelog</a></li>
    <li><a href="apidocs/index.html" title="Javadoc"><span class="none"></span>Javadoc</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Initialization</h1>
<p><b>Table of content</b></p>
<ul>
<li><a href="#Creation_of_a_Socket_instance">Creation of a Socket instance</a></li>
<li><a href="#Default_values">Default values</a></li>
<li><a href="#Description">Description</a>
<ul>
<li><a href="#IO_factory_options">IO factory options</a>
<ul>
<li><a href="#forceNew">forceNew</a></li>
<li><a href="#multiplex">multiplex</a></li></ul></li>
<li><a href="#Low-level_engine_options">Low-level engine options</a>
<ul>
<li><a href="#transports">transports</a></li>
<li><a href="#upgrade">upgrade</a></li>
<li><a href="#rememberUpgrade">rememberUpgrade</a></li>
<li><a href="#path">path</a></li>
<li><a href="#query">query</a></li>
<li><a href="#extraHeaders">extraHeaders</a></li>
<li><a href="#callFactory">callFactory</a></li>
<li><a href="#webSocketFactory">webSocketFactory</a></li></ul></li>
<li><a href="#Socket_options">Socket options</a>
<ul>
<li><a href="#auth">auth</a></li></ul></li></ul></li>
<li><a href="#SSL_connections">SSL connections</a>
<ul>
<li><a href="#With_a_keystore">With a keystore</a></li>
<li><a href="#Trust_all_certificates">Trust all certificates</a></li></ul></li></ul>
<section>
<h2><a name="Creation_of_a_Socket_instance"></a>Creation of a Socket instance</h2>

<div class="source">
<div class="source"><pre class="prettyprint">URI uri = URI.create(&quot;https://example.com&quot;);
IO.Options options = IO.Options.builder()
        // ...
        .build();

Socket socket = IO.socket(uri, options);
</pre></div></div>

<p>Unlike the JS client (which can infer it from the <code>window.location</code> object), the URI is mandatory here.</p>
<p>The <a class="externalLink" href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax">scheme</a> part of the URI is also mandatory. Both <code>ws://</code> and <code>http://</code> can be used interchangeably.</p>

<div class="source">
<div class="source"><pre class="prettyprint">Socket socket = IO.socket(&quot;https://example.com&quot;); // OK
Socket socket = IO.socket(&quot;wss://example.com&quot;); // OK, similar to the example above
Socket socket = IO.socket(&quot;192.168.0.1:1234&quot;); // NOT OK, missing the scheme part
</pre></div></div>

<p>The path represents the <a class="externalLink" href="https://socket.io/docs/v4/namespaces/">Namespace</a>, and not the actual path (see <a href="#path">below</a>) of the HTTP requests:</p>

<div class="source">
<div class="source"><pre class="prettyprint">Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;)); // the main namespace
Socket productSocket = IO.socket(URI.create(&quot;https://example.com/product&quot;)); // the &quot;product&quot; namespace
Socket orderSocket = IO.socket(URI.create(&quot;https://example.com/order&quot;)); // the &quot;order&quot; namespace
</pre></div></div>
</section><section>
<h2><a name="Default_values"></a>Default values</h2>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
    // IO factory options
    .setForceNew(false)
    .setMultiplex(true)

    // low-level engine options
    .setTransports(new String[] { Polling.NAME, WebSocket.NAME })
    .setUpgrade(true)
    .setRememberUpgrade(false)
    .setPath(&quot;/socket.io/&quot;)
    .setQuery(null)
    .setExtraHeaders(null)

    // Manager options
    .setReconnection(true)
    .setReconnectionAttempts(Integer.MAX_VALUE)
    .setReconnectionDelay(1_000)
    .setReconnectionDelayMax(5_000)
    .setRandomizationFactor(0.5)
    .setTimeout(20_000)

    // Socket options
    .setAuth(null)
    .build();
</pre></div></div>
</section><section>
<h2><a name="Description"></a>Description</h2><section>
<h3><a name="IO_factory_options"></a>IO factory options</h3>
<p>These settings will be shared by all Socket instances attached to the same Manager.</p><section>
<h4><a name="forceNew"></a><code>forceNew</code></h4>
<p>Default value: <code>false</code></p>
<p>Whether to create a new Manager instance.</p>
<p>A Manager instance is in charge of the low-level connection to the server (established with HTTP long-polling or WebSocket). It handles the reconnection logic.</p>
<p>A Socket instance is the interface which is used to sends events to &#x2014; and receive events from &#x2014; the server. It belongs to a given <a class="externalLink" href="https://socket.io/docs/v4/namespaces">namespace</a>.</p>
<p>A single Manager can be attached to several Socket instances.</p>
<p>The following example will reuse the same Manager instance for the 3 Socket instances (one single WebSocket connection):</p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setForceNew(false)
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options); // the main namespace
Socket productSocket = IO.socket(URI.create(&quot;https://example.com/product&quot;), options); // the &quot;product&quot; namespace
Socket orderSocket = IO.socket(URI.create(&quot;https://example.com/order&quot;), options); // the &quot;order&quot; namespace
</pre></div></div>

<p>The following example will create 3 different Manager instances (and thus 3 distinct WebSocket connections):</p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setForceNew(true)
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options); // the main namespace
Socket productSocket = IO.socket(URI.create(&quot;https://example.com/product&quot;), options); // the &quot;product&quot; namespace
Socket orderSocket = IO.socket(URI.create(&quot;https://example.com/order&quot;), options); // the &quot;order&quot; namespace
</pre></div></div>
</section><section>
<h4><a name="multiplex"></a><code>multiplex</code></h4>
<p>Default value: <code>true</code></p>
<p>The opposite of <code>forceNew</code>: whether to reuse an existing Manager instance.</p></section></section><section>
<h3><a name="Low-level_engine_options"></a>Low-level engine options</h3><section>
<h4><a name="transports"></a><code>transports</code></h4>
<p>Default value: <code>new String[] { Polling.NAME, WebSocket.NAME }</code></p>
<p>The low-level connection to the Socket.IO server can either be established with:</p>
<ul>

<li>HTTP long-polling: successive HTTP requests (<code>POST</code> for writing, <code>GET</code> for reading)</li>
<li><a class="externalLink" href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a></li>
</ul>
<p>The following example disables the HTTP long-polling transport:</p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setTransports(new String[] { WebSocket.NAME })
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>

<p>Note: in that case, sticky sessions are not required on the server side (more information <a class="externalLink" href="https://socket.io/docs/v4/using-multiple-nodes/">here</a>).</p></section><section>
<h4><a name="upgrade"></a><code>upgrade</code></h4>
<p>Default value: <code>true</code></p>
<p>Whether the client should try to upgrade the transport from HTTP long-polling to something better.</p></section><section>
<h4><a name="rememberUpgrade"></a><code>rememberUpgrade</code></h4>
<p>Default value: <code>false</code></p>
<p>If true and if the previous WebSocket connection to the server succeeded, the connection attempt will bypass the normal upgrade process and will initially try WebSocket. A connection attempt following a transport error will use the normal upgrade process. It is recommended you turn this on only when using SSL/TLS connections, or if you know that your network does not block websockets.</p></section><section>
<h4><a name="path"></a><code>path</code></h4>
<p>Default value: <code>/socket.io/</code></p>
<p>It is the name of the path that is captured on the server side.</p>
<p>The server and the client values must match:</p>
<p><i>Server</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">import { Server } from &quot;socket.io&quot;;

const io = new Server(8080, {
  path: &quot;/my-custom-path/&quot;
});

io.on(&quot;connection&quot;, (socket) =&gt; {
  // ...
});
</pre></div></div>

<p><i>Client</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setPath(&quot;/my-custom-path/&quot;)
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>

<p>Please note that this is different from the path in the URI, which represents the <a class="externalLink" href="https://socket.io/docs/v4/namespaces/">Namespace</a>.</p>
<p>Example:</p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setPath(&quot;/my-custom-path/&quot;)
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com/order&quot;), options);
</pre></div></div>

<ul>

<li>the Socket instance is attached to the &#x201c;order&#x201d; Namespace</li>
<li>the HTTP requests will look like: <code>GET https://example.com/my-custom-path/?EIO=4&amp;transport=polling&amp;t=ML4jUwU</code></li>
</ul></section><section>
<h4><a name="query"></a><code>query</code></h4>
<p>Default value: -</p>
<p>Additional query parameters (then found in <code>socket.handshake.query</code> object on the server-side).</p>
<p>Example:</p>
<p><i>Server</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">io.on(&quot;connection&quot;, (socket) =&gt; {
  console.log(socket.handshake.query); // prints { x: '42', EIO: '4', transport: 'polling' }
});
</pre></div></div>

<p><i>Client</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setQuery(&quot;x=42&quot;)
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>

<p>Note: The <code>socket.handshake.query</code> object contains the query parameters that were sent during the Socket.IO handshake, it won&#x2019;t be updated for the duration of the current session, which means changing the <code>query</code> on the client-side will only be effective when the current session is closed and a new one is created:</p>

<div class="source">
<div class="source"><pre class="prettyprint">socket.io().on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {
    @Override
    public void call(Object... args) {
        options.query = &quot;y=43&quot;;
    }
});
</pre></div></div>
</section><section>
<h4><a name="extraHeaders"></a><code>extraHeaders</code></h4>
<p>Default value: -</p>
<p>Additional headers (then found in <code>socket.handshake.headers</code> object on the server-side).</p>
<p>Example:</p>
<p><i>Server</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">io.on(&quot;connection&quot;, (socket) =&gt; {
  console.log(socket.handshake.headers); // prints { accept: '*/*', authorization: 'bearer 1234', connection: 'Keep-Alive', 'accept-encoding': 'gzip', 'user-agent': 'okhttp/3.12.12' }
});
</pre></div></div>

<p><i>Client</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setExtraHeaders(singletonMap(&quot;authorization&quot;, singletonList(&quot;bearer 1234&quot;)))
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>

<p>Note: Similar to the <code>query</code> option above, the <code>socket.handshake.headers</code> object contains the headers that were sent during the Socket.IO handshake, it won&#x2019;t be updated for the duration of the current session, which means changing the <code>extraHeaders</code> on the client-side will only be effective when the current session is closed and a new one is created:</p>

<div class="source">
<div class="source"><pre class="prettyprint">socket.io().on(Manager.EVENT_RECONNECT_ATTEMPT, new Emitter.Listener() {
    @Override
    public void call(Object... args) {
        options.extraHeaders.put(&quot;authorization&quot;, singletonList(&quot;bearer 5678&quot;));
    }
});
</pre></div></div>
</section><section>
<h4><a name="callFactory"></a><code>callFactory</code></h4>
<p>The <a class="externalLink" href="https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/">OkHttpClient instance</a> to use for HTTP long-polling requests.</p>

<div class="source">
<div class="source"><pre class="prettyprint">OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .readTimeout(1000, TimeUnit.MILLISECONDS)
        .writeTimeout(1000, TimeUnit.MILLISECONDS)
        .build();

IO.Options options = new IO.Options();
options.callFactory = okHttpClient;

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>
</section><section>
<h4><a name="webSocketFactory"></a><code>webSocketFactory</code></h4>
<p>The <a class="externalLink" href="https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/">OkHttpClient instance</a> to use for WebSocket connections.</p>

<div class="source">
<div class="source"><pre class="prettyprint">OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .minWebSocketMessageToCompress(2048)
        .build();

IO.Options options = new IO.Options();
options.webSocketFactory = okHttpClient;

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>
</section></section><section>
<h3><a name="Socket_options"></a>Socket options</h3>
<p>These settings are specific to the given Socket instance.</p><section>
<h4><a name="auth"></a><code>auth</code></h4>
<p>Default value: -</p>
<p>Credentials that are sent when accessing a namespace (see also <a class="externalLink" href="https://socket.io/docs/v4/middlewares/#sending-credentials">here</a>).</p>
<p>Example:</p>
<p><i>Server</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">io.on(&quot;connection&quot;, (socket) =&gt; {
  console.log(socket.handshake.auth); // prints { token: 'abcd' }
});
</pre></div></div>

<p><i>Client</i></p>

<div class="source">
<div class="source"><pre class="prettyprint">IO.Options options = IO.Options.builder()
        .setAuth(singletonMap(&quot;token&quot;, &quot;abcd&quot;))
        .build();

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>

<p>You can update the <code>auth</code> map when the access to the Namespace is denied:</p>

<div class="source">
<div class="source"><pre class="prettyprint">socket.on(Socket.EVENT_CONNECT_ERROR, new Emitter.Listener() {
    @Override
    public void call(Object... args) {
        options.auth.put(&quot;token&quot;, &quot;efgh&quot;);
        socket.connect();
    }
});
</pre></div></div>

<p>Or manually force the Socket instance to reconnect:</p>

<div class="source">
<div class="source"><pre class="prettyprint">options.auth.put(&quot;token&quot;, &quot;efgh&quot;);
socket.disconnect().connect();
</pre></div></div>
</section></section></section><section>
<h2><a name="SSL_connections"></a>SSL connections</h2><section>
<h3><a name="With_a_keystore"></a>With a keystore</h3>

<div class="source">
<div class="source"><pre class="prettyprint">HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    public boolean verify(String hostname, SSLSession sslSession) {
        return hostname.equals(&quot;example.com&quot;);
    }
};

KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
File file = new File(&quot;path/to/the/keystore.jks&quot;);
ks.load(new FileInputStream(file), &quot;password&quot;.toCharArray());

KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
kmf.init(ks, &quot;password&quot;.toCharArray());

TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
tmf.init(ks);

SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .hostnameVerifier(hostnameVerifier)
        .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) tmf.getTrustManagers()[0])
        .build();

IO.Options options = new IO.Options();
options.callFactory = okHttpClient;
options.webSocketFactory = okHttpClient;

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div>
</section><section>
<h3><a name="Trust_all_certificates"></a>Trust all certificates</h3>
<p>Please use with caution, as this defeats the whole purpose of using secure connections.</p>
<p>This is equivalent to <code>rejectUnauthorized: false</code> for the JavaScript client.</p>

<div class="source">
<div class="source"><pre class="prettyprint">HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    @Override
    public boolean verify(String hostname, SSLSession sslSession) {
        return true;
    }
};

X509TrustManager trustManager = new X509TrustManager() {
    public X509Certificate[] getAcceptedIssuers() {
        return new X509Certificate[] {};
    }

    @Override
    public void checkClientTrusted(X509Certificate[] arg0, String arg1) {
        // not implemented
    }

    @Override
    public void checkServerTrusted(X509Certificate[] arg0, String arg1) {
        // not implemented
    }
};

SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
sslContext.init(null, new TrustManager[] { trustManager }, null);

OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .hostnameVerifier(hostnameVerifier)
        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
        .build();

IO.Options options = new IO.Options();
options.callFactory = okHttpClient;
options.webSocketFactory = okHttpClient;

Socket socket = IO.socket(URI.create(&quot;https://example.com&quot;), options);
</pre></div></div></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2022
</p>
        </div>
      </div>
    </footer>
  </body>
</html>
